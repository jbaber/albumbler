#! /usr/bin/env python2

# Copyright Kyle Keen 2010
# gpl v2

import subprocess, os, random, time, sys, ConfigParser, socket
import cPickle as pickle

mpd = False
try:
    import mpd
except ImportError:
    pass
    

# defaults
conf = {
    'music_paths': [os.getenv('HOME')],
    'time_window': 60.0,
    'max_playlist': 1000,
    'min_playlist': 3,
    'notify': 'console',
    'player': 'mocp',
    'playlist_exts': ['m3u'],
    'audio_exts': ['mp3','ogg','wav','aiff','aif','m4a','wv','flac','ape']}

"""
albumlist is a cached list of all directories/playlists.

skiplist is a list of what/when was played
[ [skipped, skipped, skipped, listened, time], ... ]
Anything less than time_window is considered as skipped.
"""

# support for more players
# support more notifications
# man page
# berkely db? sqlite?
# rewrite in not python?
# context sensitive?
# add -forget
# tapered dislike between 1 minute and 1 hour

class MusicPlayer(object):
    "very important to set .album"
    def __init__(self):
        self._album = None
    def resync(self, nuke=False):
        resync(nuke)
    def filter(self, albumlist):
        return [a for a in albumlist if type(a) == str]
    @property
    def album(self):
        assert self._album is not None
        return self._album
    @album.setter
    def album(self, val):
        self._album = val
    def reasonable(self):
        return reasonable_dir(self.album)
    def message(self):
        return 'Now Playing: %s' % os.path.basename(self.album)
    def play_tunes(self):
        play_tunes(self.album)
        # but some don't template well
        player = conf['player']
        if player == 'mpd_dirs':
            host, pnum = mpd_port()
            port(host, pnum, 'clear\n')
            port(host, pnum, 'add "%s"\n' % strip_dirs(play, conf['music_paths']))
            port(host, pnum, 'play\n')
        if player == 'rhythmbox':
            call('rhythmbox-client --clear-queue')
            [call('rhythmbox-client --play-uri="%s"' % track) for track in list_files(play)]
            call('rhythmbox-client --play')
        if player == 'audacious':
            call('audtool --playlist-clear')
            [call('audtool --playlist-addurl "%s"' % track) for track in list_files(play)]
            call('audtool --playback-play')

class MpdPlayer(MusicPlayer):
    def resync(self, nuke=False):
        albumlist, skiplist = load_cache()
        old_len = len(albumlist)
        if nuke:
            albumlist = []
        print 'Querying library'
        albumlist.extend(mpd_library())
        albumlist = list(set(albumlist))
        save_cache(albumlist, skiplist)
        new_len = len(albumlist)
        print 'Index: added %i, total %i' % (new_len-old_len, new_len)
    def filter(self, albumlist):
        return [a for a in albumlist if type(a) == tuple]
    def reasonable(self):
        return True
    def message(self):
        return "Now Playing: %s - %s" % self.album
    def play_tunes(self):
        mpdc = mpd_init()
        mpdc.clear()
        # todo - check if album still exists
        mpdc.findadd('artist', self.album[0], 'album', self.album[1])
        mpdc.play()
        mpdc.disconnect()

def xdg_paths():
    j = os.path.join
    e = os.getenv
    config = e('XDG_CONFIG_HOME', j(e('HOME'), '.config'))
    config = j(config, 'albumbler', 'albumbler.config')
    cache = e('XDG_DATA_HOME', j(e('HOME'), '.local/share'))
    cache = j(cache, 'albumbler', 'albumbler.pickle')
    exclude = e('XDG_CONFIG_HOME', j(e('HOME'), '.config'))
    exclude = j(exclude, 'albumbler', 'excludes')
    return config, cache, exclude

# probably dumb to do this globally
config_path, cache_path, exclude_path = xdg_paths()

def save_cache(albumlist, skiplist):
    pickle.dump((albumlist, skiplist), open(cache_path, 'wb'), -1)

def call(string):
    pipe = subprocess.PIPE
    return subprocess.call(string, stdout=pipe, shell=True)

def port(host, number, message):
    if type(number) == str:
        number = int(number)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    #sock.setblocking(0)
    sock.connect((host, number))
    sock.send(message)
    reply = sock.recv(16384)  # 16k ought to be more than enough for anyone
    sock.close()
    return reply

def load_excludes():
    excludes = set()
    if not os.path.isfile(exclude_path):
        return excludes
    with open(exclude_path) as f:
        for line in f:
            excludes.add(line.strip('\n'))
    return excludes

def justext(name):
    return os.path.splitext(name)[1][1:]

def dir_tree(dir_root):
    excludes = load_excludes()
    tree = list(os.walk(dir_root))
    dirs = [t[0] for t in tree]
    playlists = [os.path.join(t[0],f) for t in tree for f in t[2] if justext(f) in conf['playlist_exts']]
    return [p for p in dirs + playlists if p not in excludes]

def reasonable_dir(path):
    "Estimates size of recursive add."
    if not os.path.isdir(path):  # assume any custom playlists are reasonable
        return True
    length = 0
    for p,d,files in os.walk(path):
        length += sum(justext(f) in conf['audio_exts'] for f in files)
    if length > conf['max_playlist']:
        return False
    if length < conf['min_playlist']:
        return False
    return True

def list_files(path):
    "For spoon feeding some players."
    j = os.path.join
    if justext(path) in conf['playlist_exts']:
        dn = os.path.dirname(path)
        return [j(dn, track) for track in  open(path).read().split('\n')]
    if not os.path.isdir(path):
        return ''
    return [os.path.join(p,f) for p,d,files in os.walk(path) for f in files]

def strip_dirs(track, dirs):
    # fix yucky nesting
    for d in dirs:
        if track.startswith(d):
            track = track[len(d):]
            if track.startswith('/'):
                track = track[1:]
            return track
    return track

def resync(nuke=False):
    albumlist, skiplist = load_cache()
    old_len = len(albumlist)
    if nuke:
        albumlist = []
    print 'Walking', conf['music_paths']
    [albumlist.extend(dir_tree(mp)) for mp in conf['music_paths']]
    albumlist = list(set(albumlist))
    save_cache(albumlist, skiplist)
    new_len = len(albumlist)
    print 'Index: added %i, total %i' % (new_len-old_len, new_len)

def ranking():
    albumlist, skiplist = load_cache()
    fav_list = [skips[-2] for skips in skiplist]
    bad_list = []
    [bad_list.extend(skips[:-2]) for skips in skiplist]
    fav_count = dict((f,0.0) for f in set(fav_list) | set(bad_list))
    for f in fav_list:
        fav_count[f] += 1.0
    for b in bad_list:
        fav_count[b] -= 0.1
    fav_tally = [(c,f) for f,c in fav_count.iteritems()]
    return fav_tally

def show_favorites():
    fav_tally = ranking()
    fav_tally.sort()
    fav_tally.reverse()
    for c,f in fav_tally[:100]:
        print f

def show_worst():
    fav_tally = ranking()
    fav_tally.sort()
    for c,f in fav_tally[:100]:
        print f

def update_skiplist(albumlist, skiplist, album):
    now_time = time.time()
    if len(skiplist) == 0:
        skiplist.append([album, now_time])
        save_cache(albumlist, skiplist)
        return
    last_time = skiplist[-1][-1]
    if now_time - last_time < conf['time_window']:
        skiplist[-1].pop()  # last_time
        skiplist[-1].append(album)
        skiplist[-1].append(now_time)
    else:
        skiplist.append([album, now_time])
    save_cache(albumlist, skiplist)

def load_cache():
    if not os.path.isdir(os.path.dirname(cache_path)):
        os.makedirs(os.path.dirname(cache_path))
    if not os.path.isfile(cache_path):
        save_cache([], [])
    return pickle.load(open(cache_path, 'rb'))

def load_config():
    global conf
    cp = ConfigParser.RawConfigParser()
    if not os.path.isdir(os.path.dirname(config_path)):
        os.makedirs(os.path.dirname(config_path))
    if not os.path.isfile(config_path):
        # create default file
        cp.add_section('Settings')
        cp.set('Settings', 'MusicPaths', ','.join(conf['music_paths']))
        cp.set('Settings', 'TimeWindow', str(conf['time_window']))
        cp.set('Settings', 'MaxPlaylist', str(conf['max_playlist']))
        cp.set('Settings', 'MinPlaylist', str(conf['min_playlist']))
        cp.set('Settings', 'Notify', str(conf['notify']))
        cp.set('Settings', 'Player', str(conf['player']))
        cp.set('Settings', 'PlaylistExts', ','.join(conf['playlist_exts']))
        cp.set('Settings', 'AudioExts', ','.join(conf['audio_exts']))
        cp.write(open(config_path, 'wb'))
    cp = ConfigParser.RawConfigParser()
    cp.read(config_path)
    conf['music_paths'] = cp.get('Settings', 'MusicPaths').split(',')
    conf['time_window'] = cp.getfloat('Settings', 'TimeWindow')
    conf['max_playlist'] = cp.getint('Settings', 'MaxPlaylist')
    conf['notify'] = cp.get('Settings', 'Notify')
    conf['player'] = cp.get('Settings', 'Player')
    # make a graceful upgrade path
    try:
        conf['playlist_exts'] = cp.get('Settings', 'PlaylistExts').split(',')
    except ConfigParser.NoOptionError:
        pass
    try:
        conf['min_playlist'] = cp.getint('Settings', 'MinPlaylist')
    except ConfigParser.NoOptionError:
        pass
    try:
        conf['audio_exts'] = cp.get('Settings', 'AudioExts').split(',')
    except ConfigParser.NoOptionError:
        pass

def scale_many(d, scale, paths):
    for p in paths:
        if p in d:
            d[p] *= scale
    return d

def weighted2(albumlist, skiplist):
    albumdict = dict((path, 1.0) for path in albumlist)
    if len(skiplist) == 0:
        # first time user
        return albumdict
    now_time = time.time()
    last_time = skiplist[-1][-1]
    if now_time - last_time > conf['time_window']:
        # start new session, avoid common
        all_heard = (p for skips in skiplist for p in skips[:-1])
        albumdict = scale_many(albumdict, 0.25, all_heard)
        return albumdict
    # called multiple times, do the fancy stuff
    recent = set(skiplist[-1][:-1])
    dislikes = [recent]
    all_dislikes = set(recent)
    all_skipped = [set(skips[:-2]) for skips in skiplist]
    # walk the map, discard repeats
    while dislikes[-1]:
        associated = set([])
        [associated.update(skips) for skips in all_skipped if skips & dislikes[-1]]
        associated.difference_update(all_dislikes)
        #print len(dislikes[-1]), len(associated), len(all_dislikes)
        dislikes.append(associated)
        all_dislikes.update(associated)
    # dislikes now holds map distances
    # todo: distance never above 4?
    dis_fn = lambda x: (2**x-1)/(2.0**x)
    for i,d in enumerate(dislikes):
        albumdict = scale_many(albumdict, dis_fn(i), d)
    # avoid things similar to recent
    #all_skipped = [set(skips[:-2]) for skips in skiplist]
    #similar = [p for skips in all_skipped if skips & recent for p in skips]
    # todo: be fancy and compute each distance to recent
    #albumdict = scale_many(albumdict, 0.50, similar)
    #print sorted((b,a) for a,b in albumdict.items() if b != 1.0)
    return albumdict

def emms_quote(path):
    "backslash every character to make any shell parameter safe"
    return reduce(lambda a,c: a+'\\'+c, path, "")

def emms_cmd(path):
    return '''
      (progn
        (require 'emms)
        (save-excursion
          (emms-stop)
          (condition-case nil
              (with-current-buffer emms-playlist-buffer
                (emms-playlist-clear))
            (error nil))
          (emms-add-directory-tree "%s")
          (with-current-buffer emms-playlist-buffer
            (beginning-of-buffer)
            (emms-playlist-mode-play-current-track))))
    ''' % path

def mpd_port():
    "returns (host, port)"
    host = os.getenv('MPD_HOST', 'localhost')
    pnum = os.getenv('MPD_PORT', 6600)
    return host, pnum

def mpd_init():
    if not mpd:
        print "Install python MPD library"
        sys.exit(1)
    mpdc = mpd.MPDClient()
    mpdc.connect(*mpd_port())
    return mpdc

def mpd_library():
    mpdc = mpd_init()
    albums = [(ar, al) for ar in mpdc.list('artist') \
                       for al in mpdc.list('album', 'artist', ar)]
    mpdc.disconnect()
    return albums

def play_tunes(album):
    # player : (command, args, args, ...)
    f = {'mocp': ('mocp', '--clear', '--append "%s"' % album, '--play'),
         'cmus': ('cmus-remote', '-c', '"%s"' % album,
                  '-C "view 3" "win-activate"'),
         'xmms2': ('nyxmms2', 'remove "*"', 'add "%s"' % album, 'play'),
         'clementine': ('clementine', '-s', '-l "%s"' % album, '-p'),
         'gmusicbrowser':('gmusicbrowser', '-play -playlist "%s"' % album),
         'mpc_dirs': ('mpc', 'clear',
                      'add "%s"\n' % strip_dirs(album, conf['music_paths']), 'play'),
         'emms': ('emacsclient', '-e %s' % emms_quote(emms_cmd(album))),
        }
    player = conf['player']
    if player not in f:
        return
    command = f[player][0]
    [call('%s %s' % (command, arg)) for arg in f[player][1:]]

def notify(message):
    if conf['notify'] == 'console':
        print message
    if conf['notify'] == 'notify-send':
        call('notify-send -a albumbler "%s"' % message)
    if conf['notify'] == 'ratpoison':
        call('ratpoison -c "echo %s"' % message)

def dump_cache():
    albumlist, skiplist = load_cache()
    print '(['
    for album in albumlist:
        print '    %s,' % repr(album)
    print '],['
    for skips in skiplist:
        print '    %s,' % repr(skips)
    print '])'

def main():
    load_config()
    music_player = MusicPlayer()
    if conf['player'] == 'mpd':
        music_player = MpdPlayer()
    # use real argv parsing
    if len(sys.argv) == 2:
        if sys.argv[1] == 'sync':
            music_player.resync()
        elif sys.argv[1] == 'hardsync':
            music_player.resync(nuke=True)
        elif sys.argv[1] == 'best':
            show_favorites()
        elif sys.argv[1] == 'worst':
            show_worst()
        elif sys.argv[1] == 'dump':
            dump_cache()
        else:
            print "Supported options are 'sync', 'hardsync', 'best' or 'worst'."
            print "For normal use, call without any options."
        return
    albumlist, skiplist = load_cache()
    albumlist = music_player.filter(albumlist)
    if not albumlist:
        print 'Set musicpath in %s' % config_path
        print 'And run "albumbler sync"'
        return
    albumdict = weighted2(albumlist, skiplist)
    while True:
        album = random.choice(albumdict.keys())
        odds = albumdict[album]
        if not reasonable_dir(album):
            albumdict[album] = 0.0
            continue
        if random.random() < odds:
            break
    
    update_skiplist(albumlist, skiplist, album)
    music_player.album = album
    notify(music_player.message())
    music_player.play_tunes()

if __name__ == '__main__':
    main()

